export interface UserDefinedOptions {
    [prop: string]: any;
}
export declare type TFunction<U extends TSchema = TSchema, T extends TSchema[] = []> = {
    type: 'function';
    arguments: [...T];
    returns: U;
} & UserDefinedOptions;
export declare type TConstructor<U extends TSchema = TSchema, T extends TSchema[] = []> = {
    type: 'constructor';
    arguments: [...T];
    returns: U;
} & UserDefinedOptions;
declare type TContract = TConstructor | TFunction;
export declare type TIntersect<T extends TSchema[] = any> = {
    allOf: [...T];
} & UserDefinedOptions;
export declare type TUnion<T extends TSchema[] = any> = {
    oneOf: [...T];
} & UserDefinedOptions;
export declare type TTuple<T extends TSchema[] = any> = {
    type: 'array';
    items: [...T];
    additionalItems: false;
    minItems: number;
    maxItems: number;
} & UserDefinedOptions;
export declare type TComposite = TIntersect | TUnion | TTuple;
export declare const OptionalModifier: unique symbol;
export declare const ReadonlyModifier: unique symbol;
export declare type TOptional<T extends TSchema | TComposite> = T & {
    modifier: typeof OptionalModifier;
};
export declare type TReadonly<T extends TSchema | TComposite> = T & {
    modifier: typeof ReadonlyModifier;
};
export declare type TModifier = TOptional<TSchema | TComposite> | TReadonly<TSchema | TComposite>;
export declare type FormatOption = 'date-time' | 'time' | 'date' | 'email' | 'idn-email' | 'hostname' | 'idn-hostname' | 'ipv4' | 'ipv6' | 'uri' | 'uri-reference' | 'iri' | 'uuid' | 'iri-reference' | 'uri-template' | 'json-pointer' | 'relative-json-pointer' | 'regex';
export declare type ArrayOptions = {
    minItems?: number;
    maxItems?: number;
    uniqueItems?: boolean;
} & UserDefinedOptions;
export declare type NumberOptions = {
    minimum?: number;
    exclusiveMinimum?: number;
    maximum?: number;
    exclusiveMaximum?: number;
    multipleOf?: number;
} & UserDefinedOptions;
/** Augmentation support for UserDefinedOptions. Used specifically for adding custom string formats. */
declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
declare type IsUnion<T> = [T] extends [UnionToIntersection<T>] ? false : true;
export declare type StringOptions = {
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    format?: IsUnion<UserDefinedOptions['format']> extends true ? UserDefinedOptions['format'] | FormatOption : FormatOption;
} & Omit<UserDefinedOptions, 'format'>;
export declare type TLiteral = TStringLiteral<string> | TNumberLiteral<number> | TBooleanLiteral<boolean>;
export declare type TStringLiteral<T> = {
    type: 'string';
    enum: [T];
} & UserDefinedOptions;
export declare type TNumberLiteral<T> = {
    type: 'number';
    enum: [T];
} & UserDefinedOptions;
export declare type TBooleanLiteral<T> = {
    type: 'boolean';
    enum: [T];
} & UserDefinedOptions;
export declare type TProperties = {
    [key: string]: TSchema | TComposite | TOptional<TSchema | TComposite> | TReadonly<TSchema | TComposite>;
};
export declare type TObject<T extends TProperties> = {
    type: 'object';
    properties: T;
    required?: string[];
} & UserDefinedOptions;
export declare type TMap<T extends TSchema | TComposite> = {
    type: 'object';
    additionalProperties: T;
} & UserDefinedOptions;
export declare type TArray<T extends TSchema | TComposite> = {
    type: 'array';
    items: T;
} & ArrayOptions;
export declare type TEnum<T extends string | number> = {
    enum: Array<T>;
} & UserDefinedOptions;
export declare type TNumber = {
    type: 'number';
} & NumberOptions;
export declare type TInteger = {
    type: 'integer';
} & NumberOptions;
export declare type TString = {
    type: 'string';
} & StringOptions;
export declare type TBoolean = {
    type: 'boolean';
} & UserDefinedOptions;
export declare type TNull = {
    type: 'null';
} & UserDefinedOptions;
export declare type TAny = {} & UserDefinedOptions;
export declare type TPromise<T extends TSchema | TVoid | TUndefined> = {
    type: 'promise';
    item: T;
} & UserDefinedOptions;
export declare type TUndefined = {
    type: 'undefined';
} & UserDefinedOptions;
export declare type TVoid = {
    type: 'void';
} & UserDefinedOptions;
export declare type TSchema = TLiteral | TNumber | TInteger | TBoolean | TString | TObject<any> | TArray<any> | TEnum<any> | TMap<any> | TNull | TAny | TPromise<any> | TUndefined | TVoid;
declare type StaticFunction<T> = T extends TFunction<infer R, infer U> ? (args: [...Static<U>]) => Static<R> : never;
declare type StaticConstructor<T> = T extends TConstructor<infer R, infer U> ? new (args: [...Static<U>]) => Static<R> : never;
declare type StaticContract<T extends TSchema> = T extends TFunction ? StaticFunction<T> : T extends TConstructor ? StaticConstructor<T> : never;
declare type MapStatic<T> = {
    [P in keyof T]: Static<T[P]>;
};
declare type StaticIntersect<T> = T extends TIntersect<infer U> ? UnionToIntersection<MapStatic<U>[number]> : never;
declare type StaticUnion<T> = T extends TUnion<infer U> ? MapStatic<U>[number] : never;
declare type StaticTuple<T> = T extends TTuple<infer U> ? MapStatic<U> : never;
declare type StaticComposite<T extends TComposite> = T extends TIntersect ? StaticIntersect<T> : T extends TUnion ? StaticUnion<T> : T extends TTuple ? StaticTuple<T> : never;
declare type StaticLiteral<T> = T extends TStringLiteral<infer U> ? U : T extends TNumberLiteral<infer U> ? U : T extends TBooleanLiteral<infer U> ? U : never;
declare type ReadonlyPropertyKeys<T> = {
    [K in keyof T]: T[K] extends TReadonly<infer U> ? K : never;
}[keyof T];
declare type OptionalPropertyKeys<T> = {
    [K in keyof T]: T[K] extends TOptional<infer U> ? K : never;
}[keyof T];
declare type PropertyKeys<T> = keyof Omit<T, OptionalPropertyKeys<T> | ReadonlyPropertyKeys<T>>;
declare type StaticObjectProperties<T> = {
    readonly [K in ReadonlyPropertyKeys<T>]: Static<T[K]>;
} & {
    [K in OptionalPropertyKeys<T>]?: Static<T[K]>;
} & {
    [K in PropertyKeys<T>]: Static<T[K]>;
};
declare type StaticSchema<T extends TSchema> = T extends TObject<infer U> ? StaticObjectProperties<U> : T extends TMap<infer U> ? {
    [key: string]: Static<U>;
} : T extends TArray<infer U> ? Array<Static<U>> : T extends TEnum<infer U> ? U : T extends TLiteral ? StaticLiteral<T> : T extends TString ? string : T extends TNumber ? number : T extends TInteger ? number : T extends TBoolean ? boolean : T extends TNull ? null : T extends TAny ? any : T extends TPromise<infer U> ? Promise<Static<U>> : T extends TVoid ? void : T extends TUndefined ? undefined : never;
export declare type TStatic = TComposite | TSchema | TModifier | TContract;
export declare type Static<T extends TStatic> = T extends TContract ? StaticContract<T> : T extends TComposite ? StaticComposite<T> : T extends TSchema ? StaticSchema<T> : never;
export declare class Type {
    /** Modifies the inner type T into an optional T. */
    static Optional<T extends TSchema | TUnion | TIntersect>(item: T): TOptional<T>;
    /** Modifies the inner type T into an readonly T. */
    static Readonly<T extends TSchema | TUnion | TIntersect>(item: T): TReadonly<T>;
    /** Creates a Union type for the given arguments. */
    static Union<T extends TSchema[]>(items: [...T], options?: UserDefinedOptions): TUnion<T>;
    /** Creates an Intersect type for the given arguments. */
    static Intersect<T extends TSchema[]>(items: [...T], options?: UserDefinedOptions): TIntersect<T>;
    /** Creates a Tuple type for the given arguments. */
    static Tuple<T extends TSchema[]>(items: [...T], options?: UserDefinedOptions): TTuple<T>;
    /** Creates a `function` type for the given arguments. */
    static Function<U extends TSchema, T extends TSchema[] = []>(args: T, returns: U, options?: UserDefinedOptions): TFunction<U, T>;
    /** Creates a `constructor` type for the given arguments. */
    static Constructor<U extends TSchema, T extends TSchema[] = []>(args: T, returns: U, options?: UserDefinedOptions): TConstructor<U, T>;
    /** Creates a `Promise<T>` type. */
    static Promise<T extends TSchema>(item: T, options?: UserDefinedOptions): TPromise<T>;
    /** Creates a `void` type. */
    static Void(options?: UserDefinedOptions): TVoid;
    /** Creates a `undefined` type. */
    static Undefined(options?: UserDefinedOptions): TUndefined;
    /** Creates a `string` literal for the given value. */
    static Literal<T extends string>(value: T, options?: UserDefinedOptions): TStringLiteral<T>;
    /** Creates a `number` literal for the given value. */
    static Literal<T extends number>(value: T, options?: UserDefinedOptions): TNumberLiteral<T>;
    /** Creates a `boolean` literal for the given value. */
    static Literal<T extends boolean>(value: T, options?: UserDefinedOptions): TBooleanLiteral<T>;
    /** Creates a `object` type with the given properties. */
    static Object<T extends TProperties>(properties: T, options?: UserDefinedOptions): TObject<T>;
    /** Creates a `{[key: string]: T}` type for the given item. */
    static Map<T extends TSchema | TUnion | TIntersect | TTuple>(item: T, options?: UserDefinedOptions): TMap<T>;
    /** Creates an `Array<T>` type for the given item.` */
    static Array<T extends TSchema | TUnion | TIntersect | TTuple>(items: T, options?: ArrayOptions): TArray<T>;
    /** Creates an `Enum<T>` from an existing TypeScript enum definition. */
    static Enum<T extends Record<string, string | number>>(item: T, options?: UserDefinedOptions): TEnum<T[keyof T]>;
    /** Creates a `string` type. */
    static String(options?: StringOptions): TString;
    /** Creates a `number` type. */
    static Number(options?: NumberOptions): TNumber;
    /** Creates a `number` type that checks for `integer`. */
    static Integer(options?: NumberOptions): TInteger;
    /** Creates a `boolean` type. */
    static Boolean(options?: UserDefinedOptions): TBoolean;
    /** Creates a `null` type. */
    static Null(options?: UserDefinedOptions): TNull;
    /** Creates a `any` type. */
    static Any(options?: UserDefinedOptions): TAny;
    /** Creates a `string` type that validates for the given regular expression. Alias for ```Type.String({ pattern: '...' })``` */
    static Pattern(regex: RegExp): TString;
    /**
     * Deprecated: Use `Type.String({ format: 'uuid' })`
     *
     * Creates a `string` type that validate a Guid. Alias for ```Type.String({ pattern: '...' })```
     */
    static Guid(): TString;
}
export {};
