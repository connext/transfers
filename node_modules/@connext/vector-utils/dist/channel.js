"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBalanceForAssetId = exports.hashChannelCommitment = exports.hashCoreChannelState = exports.encodeCoreChannelState = exports.hashBalances = exports.hashBalance = void 0;
const vector_types_1 = require("@connext/vector-types");
const ethers_1 = require("ethers");
const { keccak256, solidityPack, defaultAbiCoder } = ethers_1.utils;
exports.hashBalance = (balance) => {
    return keccak256(solidityPack(["bytes32", "bytes32"], [keccak256(solidityPack(["uint256[]"], [balance.amount])), keccak256(solidityPack(["address[]"], [balance.to]))]));
};
exports.hashBalances = (balances) => {
    return keccak256(solidityPack(["bytes32[]"], [balances.map(exports.hashBalance)]));
};
exports.encodeCoreChannelState = (state) => {
    return defaultAbiCoder.encode([vector_types_1.CoreChannelStateEncoding], [state]);
};
exports.hashCoreChannelState = (state) => {
    return keccak256(solidityPack(["bytes"], [exports.encodeCoreChannelState(state)]));
};
exports.hashChannelCommitment = (commitment) => {
    return keccak256(solidityPack(["bytes32", "address", "uint256"], [exports.hashCoreChannelState(commitment.state), commitment.channelFactoryAddress, commitment.chainId.toString()]));
};
exports.getBalanceForAssetId = (channel, assetId, participant) => {
    const assetIdx = channel.assetIds.findIndex(a => a === assetId);
    if (assetIdx === -1) {
        return "0";
    }
    return channel.balances[assetIdx].amount[participant === "alice" ? 0 : 1];
};
//# sourceMappingURL=channel.js.map