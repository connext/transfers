import { EngineEvent, EngineEventMap, INodeService, Result, ServerNodeParams, ServerNodeResponses, NodeError, OptionalPublicIdentifier } from "@connext/vector-types";
import { Evt } from "evt";
import { BaseLogger } from "pino";
export declare type EventCallbackConfig = {
    [event in keyof EngineEventMap]: {
        evt?: Evt<EngineEventMap[event]>;
        url?: string;
    };
};
export declare class RestServerNodeService implements INodeService {
    private readonly serverNodeUrl;
    private readonly logger;
    private readonly evts?;
    publicIdentifier: string;
    signerAddress: string;
    private readonly ctxs;
    private constructor();
    static connect(serverNodeUrl: string, logger: BaseLogger, evts?: EventCallbackConfig, index?: number): Promise<RestServerNodeService>;
    getConfig(): Promise<Result<ServerNodeResponses.GetConfig, NodeError>>;
    createNode(params: ServerNodeParams.CreateNode): Promise<Result<ServerNodeResponses.CreateNode, NodeError>>;
    getStateChannel(params: OptionalPublicIdentifier<ServerNodeParams.GetChannelState>): Promise<Result<ServerNodeResponses.GetChannelState, NodeError>>;
    getStateChannels(params: OptionalPublicIdentifier<ServerNodeParams.GetChannelStates>): Promise<Result<ServerNodeResponses.GetChannelStates, NodeError>>;
    getTransfersByRoutingId(params: OptionalPublicIdentifier<ServerNodeParams.GetTransferStatesByRoutingId>): Promise<Result<ServerNodeResponses.GetTransferStatesByRoutingId, NodeError>>;
    getTransferByRoutingId(params: OptionalPublicIdentifier<ServerNodeParams.GetTransferStateByRoutingId>): Promise<Result<ServerNodeResponses.GetTransferStateByRoutingId, NodeError>>;
    getTransfer(params: OptionalPublicIdentifier<ServerNodeParams.GetTransferState>): Promise<Result<ServerNodeResponses.GetTransferState, NodeError>>;
    getActiveTransfers(params: OptionalPublicIdentifier<ServerNodeParams.GetActiveTransfersByChannelAddress>): Promise<Result<ServerNodeResponses.GetActiveTransfersByChannelAddress, NodeError>>;
    getStateChannelByParticipants(params: OptionalPublicIdentifier<ServerNodeParams.GetChannelStateByParticipants>): Promise<Result<ServerNodeResponses.GetChannelStateByParticipants, NodeError>>;
    setup(params: OptionalPublicIdentifier<ServerNodeParams.RequestSetup>): Promise<Result<ServerNodeResponses.RequestSetup, NodeError>>;
    internalSetup(params: OptionalPublicIdentifier<ServerNodeParams.Setup>): Promise<Result<ServerNodeResponses.Setup, NodeError>>;
    sendDepositTx(params: OptionalPublicIdentifier<ServerNodeParams.SendDepositTx>): Promise<Result<ServerNodeResponses.SendDepositTx, NodeError>>;
    reconcileDeposit(params: OptionalPublicIdentifier<ServerNodeParams.Deposit>): Promise<Result<ServerNodeResponses.Deposit, NodeError>>;
    requestCollateral(params: OptionalPublicIdentifier<ServerNodeParams.RequestCollateral>): Promise<Result<ServerNodeResponses.RequestCollateral, NodeError>>;
    conditionalTransfer(params: OptionalPublicIdentifier<ServerNodeParams.ConditionalTransfer>): Promise<Result<ServerNodeResponses.ConditionalTransfer, NodeError>>;
    resolveTransfer(params: OptionalPublicIdentifier<ServerNodeParams.ResolveTransfer>): Promise<Result<ServerNodeResponses.ResolveTransfer, NodeError>>;
    withdraw(params: OptionalPublicIdentifier<ServerNodeParams.Withdraw>): Promise<Result<ServerNodeResponses.Withdraw, NodeError>>;
    once<T extends EngineEvent>(event: T, callback: (payload: EngineEventMap[T]) => void | Promise<void>, filter?: (payload: EngineEventMap[T]) => boolean, publicIdentifier?: string): void;
    on<T extends EngineEvent>(event: T, callback: (payload: EngineEventMap[T]) => void | Promise<void>, filter?: (payload: EngineEventMap[T]) => boolean, publicIdentifier?: string): void;
    waitFor<T extends EngineEvent>(event: T, timeout: number, filter?: (payload: EngineEventMap[T]) => boolean, publicIdentifier?: string): Promise<EngineEventMap[T] | undefined>;
    off<T extends EngineEvent>(event: T, publicIdentifier?: string): void;
    private executeHttpRequest;
}
//# sourceMappingURL=serverNode.d.ts.map