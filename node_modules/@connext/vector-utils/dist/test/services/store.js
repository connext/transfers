"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryStoreService = void 0;
class MemoryStoreService {
    constructor() {
        this.transfersInChannel = new Map();
        this.transfers = new Map();
        this.channelStates = new Map();
        this.schemaVersion = undefined;
    }
    getTransactionByHash(transactionHash) {
        throw new Error("Method not implemented.");
    }
    saveTransactionFailure(channelAddress, transactionHash, error) {
        throw new Error("Method not implemented.");
    }
    saveTransactionReceipt(channelAddress, transaction) {
        throw new Error("Method not implemented.");
    }
    saveTransactionResponse(channelAddress, transactionReason, response) {
        throw new Error("Method not implemented.");
    }
    connect() {
        return Promise.resolve();
    }
    disconnect() {
        return Promise.resolve();
    }
    clear() {
        this.channelStates.clear();
        this.transfersInChannel.clear();
        this.transfers.clear();
        return Promise.resolve();
    }
    getChannelState(channelAddress) {
        var _a;
        const { state } = (_a = this.channelStates.get(channelAddress)) !== null && _a !== void 0 ? _a : {};
        return Promise.resolve(state);
    }
    getChannelStateByParticipants(participantA, participantB, chainId) {
        var _a;
        return Promise.resolve((_a = [...this.channelStates.values()].find(channelState => {
            channelState.state.alice === participantA &&
                channelState.state.bob === participantB &&
                channelState.state.networkContext.chainId === chainId;
        })) === null || _a === void 0 ? void 0 : _a.state);
    }
    getChannelStates() {
        return Promise.resolve([...this.channelStates.values()].map(c => c.state));
    }
    saveChannelState(channelState, commitment, transfer) {
        var _a;
        this.channelStates.set(channelState.channelAddress, {
            state: Object.assign({}, channelState),
            commitment,
        });
        if (!transfer) {
            return Promise.resolve();
        }
        this.transfers.set(transfer.transferId, transfer);
        const activeTransfers = (_a = this.transfersInChannel.get(channelState.channelAddress)) !== null && _a !== void 0 ? _a : [];
        if (transfer.transferResolver) {
            this.transfersInChannel.set(channelState.channelAddress, activeTransfers.filter(x => x !== transfer.transferId));
            return Promise.resolve();
        }
        this.transfersInChannel.set(channelState.channelAddress, [...activeTransfers, transfer.transferId]);
        return Promise.resolve();
    }
    getActiveTransfers(channelAddress) {
        var _a;
        const active = [...((_a = this.transfersInChannel.get(channelAddress)) !== null && _a !== void 0 ? _a : [])];
        const all = active.map(id => this.transfers.get(id)).filter(x => !!x);
        return Promise.resolve(all);
    }
    getTransferState(transferId) {
        return Promise.resolve(this.transfers.get(transferId));
    }
    getTransfersByRoutingId(routingId) {
        throw new Error("Method not implemented.");
    }
    getChannelCommitment(channelAddress) {
        var _a;
        return Promise.resolve((_a = this.channelStates.get(channelAddress)) === null || _a === void 0 ? void 0 : _a.commitment);
    }
    getSchemaVersion() {
        return Promise.resolve(this.schemaVersion);
    }
    updateSchemaVersion(version) {
        this.schemaVersion = version;
        return Promise.resolve();
    }
    getWithdrawalCommitment(transferId) {
        return Promise.resolve(undefined);
    }
    saveWithdrawalCommitment(transferId, withdrawCommitment) {
        return Promise.resolve();
    }
    getTransferByRoutingId(channelAddress, routingId) {
        return Promise.resolve(undefined);
    }
}
exports.MemoryStoreService = MemoryStoreService;
//# sourceMappingURL=store.js.map