import { Address, Bytes32 } from "./basic";
import { Balance, FullTransferState } from "./channel";
import { EngineParams } from "./schemas";
import { TransferName } from "./transferDefinitions";
import { ChannelRpcMethod, ChannelRpcMethodsResponsesMap } from "./vectorProvider";
export declare type ConditionalTransferResponse = {
    routingId: Bytes32;
};
export declare const SETUP_EVENT = "SETUP";
export declare type SetupPayload = {
    channelAddress: string;
    aliceIdentifier: string;
    bobIdentifier: string;
    chainId: number;
};
export declare const CONDITIONAL_TRANSFER_CREATED_EVENT = "CONDITIONAL_TRANSFER_CREATED";
export declare type ConditionalTransferCreatedPayload = {
    aliceIdentifier: string;
    bobIdentifier: string;
    channelAddress: string;
    transfer: FullTransferState;
    channelBalance: Balance;
    conditionType: TransferName | Address;
    activeTransferIds?: string[];
};
export declare const CONDITIONAL_TRANSFER_RESOLVED_EVENT = "CONDITIONAL_TRANSFER_RESOLVED";
export declare type ConditionalTransferResolvedPayload = ConditionalTransferCreatedPayload;
export declare const DEPOSIT_RECONCILED_EVENT = "DEPOSIT_RECONCILED";
export declare type DepositReconciledPayload = {
    aliceIdentifier: string;
    bobIdentifier: string;
    channelAddress: string;
    assetId: string;
    channelBalance: Balance;
};
export declare const REQUEST_COLLATERAL_EVENT = "REQUEST_COLLATERAL";
export declare type RequestCollateralPayload = {
    aliceIdentifier: string;
    bobIdentifier: string;
    channelAddress: string;
    assetId: string;
    amount?: string;
};
export declare const WITHDRAWAL_CREATED_EVENT = "WITHDRAWAL_CREATED";
export declare type WithdrawalCreatedPayload = {
    aliceIdentifier: string;
    bobIdentifier: string;
    channelAddress: string;
    transfer: FullTransferState;
    fee: string;
    assetId: string;
    amount: string;
    recipient: string;
    channelBalance: Balance;
};
export declare const WITHDRAWAL_RESOLVED_EVENT = "WITHDRAWAL_RESOLVED";
export declare type WithdrawalResolvedPayload = WithdrawalCreatedPayload;
export declare const WITHDRAWAL_RECONCILED_EVENT = "WITHDRAWAL_RECONCILED";
export declare type WithdrawalReconciledPayload = {
    aliceIdentifier: string;
    bobIdentifier: string;
    channelAddress: string;
    transactionHash: string;
    transferId: string;
};
export declare const EngineEvents: {
    readonly SETUP: "SETUP";
    readonly CONDITIONAL_TRANSFER_CREATED: "CONDITIONAL_TRANSFER_CREATED";
    readonly CONDITIONAL_TRANSFER_RESOLVED: "CONDITIONAL_TRANSFER_RESOLVED";
    readonly DEPOSIT_RECONCILED: "DEPOSIT_RECONCILED";
    readonly REQUEST_COLLATERAL: "REQUEST_COLLATERAL";
    readonly WITHDRAWAL_CREATED: "WITHDRAWAL_CREATED";
    readonly WITHDRAWAL_RESOLVED: "WITHDRAWAL_RESOLVED";
    readonly WITHDRAWAL_RECONCILED: "WITHDRAWAL_RECONCILED";
};
export declare type EngineEvent = typeof EngineEvents[keyof typeof EngineEvents];
export interface EngineEventMap {
    [SETUP_EVENT]: SetupPayload;
    [CONDITIONAL_TRANSFER_CREATED_EVENT]: ConditionalTransferCreatedPayload;
    [CONDITIONAL_TRANSFER_RESOLVED_EVENT]: ConditionalTransferResolvedPayload;
    [DEPOSIT_RECONCILED_EVENT]: DepositReconciledPayload;
    [REQUEST_COLLATERAL_EVENT]: RequestCollateralPayload;
    [WITHDRAWAL_CREATED_EVENT]: WithdrawalCreatedPayload;
    [WITHDRAWAL_RESOLVED_EVENT]: WithdrawalResolvedPayload;
    [WITHDRAWAL_RECONCILED_EVENT]: WithdrawalReconciledPayload;
}
export interface IVectorEngine {
    publicIdentifier: string;
    signerAddress: string;
    request<T extends ChannelRpcMethod>(payload: EngineParams.RpcRequest): Promise<ChannelRpcMethodsResponsesMap[T]>;
    on<T extends EngineEvent>(event: T, callback: (payload: EngineEventMap[T]) => void | Promise<void>, filter?: (payload: EngineEventMap[T]) => boolean): void;
    once<T extends EngineEvent>(event: T, callback: (payload: EngineEventMap[T]) => void | Promise<void>, filter?: (payload: EngineEventMap[T]) => boolean): void;
    waitFor<T extends EngineEvent>(event: T, timeout: number, filter?: (payload: EngineEventMap[T]) => boolean): Promise<EngineEventMap[T]>;
    off<T extends EngineEvent>(event?: T): void;
}
//# sourceMappingURL=engine.d.ts.map