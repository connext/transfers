import { providers } from "ethers";
import { WithdrawCommitmentJson } from "./transferDefinitions/withdraw";
import { FullChannelState, ChannelCommitmentData, FullTransferState } from "./channel";
import { Address } from "./basic";
export interface IVectorStore {
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    getSchemaVersion(): Promise<number | undefined>;
    updateSchemaVersion(version?: number): Promise<void>;
    clear(): Promise<void>;
    getChannelStates(): Promise<FullChannelState[]>;
    getChannelState(channelAddress: string): Promise<FullChannelState | undefined>;
    getChannelStateByParticipants(participantA: string, participantB: string, chainId: number): Promise<FullChannelState | undefined>;
    getChannelCommitment(channelAddress: string): Promise<ChannelCommitmentData | undefined>;
    getActiveTransfers(channelAddress: string): Promise<FullTransferState[]>;
    getTransferState(transferId: string): Promise<FullTransferState | undefined>;
    saveChannelState(channelState: FullChannelState, commitment: ChannelCommitmentData, transfer?: FullTransferState): Promise<void>;
}
export declare const StoredTransactionStatus: {
    readonly submitted: "submitted";
    readonly mined: "mined";
    readonly failed: "failed";
};
export declare type StoredTransactionStatus = keyof typeof StoredTransactionStatus;
export declare const TransactionReason: {
    readonly allowance: "allowance";
    readonly approveTokens: "approveTokens";
    readonly disputeChannel: "disputeChannel";
    readonly disputeTransfer: "disputeTransfer";
    readonly defundChannel: "defundChannel";
    readonly defundTransfer: "defundTransfer";
    readonly depositA: "depositA";
    readonly depositB: "depositB";
    readonly deployWithDepositA: "deployWithDepositA";
    readonly transferTokens: "transferTokens";
    readonly withdraw: "withdraw";
};
export declare type TransactionReason = keyof typeof TransactionReason;
export declare type StoredTransaction = {
    channelAddress: string;
    status: StoredTransactionStatus;
    reason: TransactionReason;
    error?: string;
    to: Address;
    from: Address;
    data: string;
    value: string;
    chainId: number;
    nonce: number;
    gasLimit: string;
    gasPrice: string;
    transactionHash: string;
    timestamp?: number;
    raw?: string;
    blockHash?: string;
    blockNumber?: number;
    logs?: string;
    contractAddress?: string;
    transactionIndex?: number;
    root?: string;
    gasUsed?: string;
    logsBloom?: string;
    cumulativeGasUsed?: string;
    byzantium?: boolean;
};
export interface IChainServiceStore {
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    clear(): Promise<void>;
    getTransactionByHash(transactionHash: string): Promise<StoredTransaction | undefined>;
    saveTransactionResponse(channelAddress: string, reason: TransactionReason, transaction: providers.TransactionResponse): Promise<void>;
    saveTransactionReceipt(channelAddress: string, transaction: providers.TransactionReceipt): Promise<void>;
    saveTransactionFailure(channelAddress: string, transactionHash: string, error: string): Promise<void>;
}
export interface IEngineStore extends IVectorStore, IChainServiceStore {
    getWithdrawalCommitment(transferId: string): Promise<WithdrawCommitmentJson | undefined>;
    getTransferByRoutingId(channelAddress: string, routingId: string): Promise<FullTransferState | undefined>;
    getTransfersByRoutingId(routingId: string): Promise<FullTransferState[]>;
    saveWithdrawalCommitment(transferId: string, withdrawCommitment: WithdrawCommitmentJson): Promise<void>;
}
//# sourceMappingURL=store.d.ts.map