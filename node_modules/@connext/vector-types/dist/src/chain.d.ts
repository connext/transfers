import { BigNumber, BigNumberish, providers } from "ethers";
import { Address, HexString } from "./basic";
import { Balance, FullChannelState, FullTransferState } from "./channel";
import { Result, Values, VectorError } from "./error";
import { ChainProviders } from "./network";
import { RegisteredTransfer, TransferName } from "./transferDefinitions";
export declare const ERC20Abi: string[];
export declare class ChainError extends VectorError {
    readonly message: Values<typeof ChainError.reasons>;
    readonly context: any;
    readonly type: "ChainError";
    static readonly reasons: {
        ProviderNotFound: string;
        SignerNotFound: string;
        SenderNotInChannel: string;
        NotEnoughFunds: string;
        FailedToSendTx: string;
        TransferNotRegistered: string;
        MissingSigs: string;
        ResolverNeeded: string;
        NotInitialState: string;
    };
    static readonly retryableTxErrors: {
        BadNonce: string;
        InvalidNonce: string;
        MissingHash: string;
        UnderpricedReplancement: string;
    };
    readonly canRetry: boolean;
    constructor(message: Values<typeof ChainError.reasons>, context?: any);
}
export declare type MinimalTransaction = {
    to: Address;
    value: BigNumberish;
    data: HexString;
};
export declare type MultisigTransaction = MinimalTransaction & {
    nonce: BigNumberish;
};
export interface IVectorChainReader {
    getChannelOnchainBalance(channelAddress: string, chainId: number, assetId: string): Promise<Result<BigNumber, ChainError>>;
    getTotalDepositedA(channelAddress: string, chainId: number, assetId: string): Promise<Result<BigNumber, ChainError>>;
    getTotalDepositedB(channelAddress: string, chainId: number, assetId: string): Promise<Result<BigNumber, ChainError>>;
    getChannelFactoryBytecode(channelFactoryAddress: string, chainId: number): Promise<Result<string, ChainError>>;
    getChannelMastercopyAddress(channelFactoryAddress: string, chainId: number): Promise<Result<string, ChainError>>;
    getChannelAddress(initiator: string, responder: string, channelFactoryAddress: string, chainId: number): Promise<Result<string, ChainError>>;
    getRegisteredTransferByName(name: TransferName, transferRegistry: string, chainId: number, bytecode?: string): Promise<Result<RegisteredTransfer, ChainError>>;
    getRegisteredTransferByDefinition(definition: Address, transferRegistry: string, chainId: number, bytecode?: string): Promise<Result<RegisteredTransfer, ChainError>>;
    getChainProviders(): Result<ChainProviders, ChainError>;
    create(transfer: FullTransferState, chainId: number, bytecode?: string): Promise<Result<boolean, ChainError>>;
    resolve(transfer: FullTransferState, chainId: number, bytecode?: string): Promise<Result<Balance, ChainError>>;
    getCode(address: Address, chainId: number): Promise<Result<string, ChainError>>;
    getBlockNumber(chainId: number): Promise<Result<number, ChainError>>;
}
export interface IVectorChainService extends IVectorChainReader {
    sendDepositTx(channelState: FullChannelState, sender: string, amount: string, assetId: string): Promise<Result<providers.TransactionResponse, ChainError>>;
    sendWithdrawTx(channelState: FullChannelState, minTx: MinimalTransaction): Promise<Result<providers.TransactionResponse, ChainError>>;
    sendDisputeChannelTx(channelState: FullChannelState): Promise<Result<providers.TransactionResponse, ChainError>>;
    sendDefundChannelTx(channelState: FullChannelState): Promise<Result<providers.TransactionResponse, ChainError>>;
    sendDisputeTransferTx(transferState: FullTransferState, merkleProof: string[]): Promise<Result<providers.TransactionResponse, ChainError>>;
    sendDefundTransferTx(transferState: FullTransferState): Promise<Result<providers.TransactionResponse, ChainError>>;
}
//# sourceMappingURL=chain.d.ts.map