export class Result {
    constructor(error, value) {
        if (error) {
            this.isError = true;
            this.error = error;
        }
        else {
            this.isError = false;
            this.value = value;
        }
    }
    getValue() {
        if (this.isError) {
            throw new Error(`Can't getValue() of error result: ${this.error}`);
        }
        return this.value;
    }
    getError() {
        if (this.isError) {
            return this.error;
        }
        return undefined;
    }
    static fail(error) {
        return new Result(error);
    }
    static ok(result) {
        return new Result(undefined, result);
    }
}
export class VectorError extends Error {
    constructor(message, context) {
        super(message);
        this.message = message;
        this.context = context;
    }
}
VectorError.errors = {
    OutboundChannelUpdateError: "OutboundChannelUpdateError",
    InboundChannelUpdateError: "InboundChannelUpdateError",
    ChainError: "ChainError",
    ValidationError: "ValidationError",
    RouterError: "RouterError",
    NodeError: "NodeError",
    LockError: "LockError",
    MessagingError: "MessagingError",
};
export class ValidationError extends VectorError {
    constructor(message, params, state, context) {
        super(message, context);
        this.message = message;
        this.params = params;
        this.state = state;
        this.context = context;
        this.type = VectorError.errors.ValidationError;
    }
}
ValidationError.reasons = {
    BadUpdateType: "Unrecognized update type",
    ChannelAlreadySetup: "Channel is already setup",
    ChannelNotFound: "No channel found in storage",
    SetupTimeoutInvalid: "Provided state timeout is invalid",
    TransferNotActive: "Transfer not found in activeTransfers",
    TransferNotFound: "No transfer found in storage",
    ExternalValidationFailed: "Failed external validation",
};
export class OutboundChannelUpdateError extends VectorError {
    constructor(message, params, state, context) {
        super(message, context);
        this.message = message;
        this.params = params;
        this.state = state;
        this.context = context;
        this.type = VectorError.errors.OutboundChannelUpdateError;
    }
}
OutboundChannelUpdateError.reasons = {
    ApplyUpdateFailed: "Failed to apply update",
    BadSignatures: "Could not recover signers",
    BadUpdateType: "Unrecognized update type",
    ChannelNotFound: "No channel found in storage",
    CounterpartyFailure: "Counterparty failed to apply update",
    Create2Failed: "Failed to get create2 address",
    InvalidParams: "Invalid params",
    MessageFailed: "Failed to send message",
    OutboundValidationFailed: "Requested update is invalid",
    RestoreNeeded: "Channel too far out of sync, must be restored",
    RegenerateUpdateFailed: "Failed to regenerate update after sync",
    SaveChannelFailed: "Failed to save channel",
    StaleChannelNoUpdate: "Channel nonce is behind, no latest update from counterparty",
    StaleChannel: "Channel state is behind, cannot apply update",
    SyncSingleSigned: "Counterparty gave single signed update to sync, refusing",
    SyncFailure: "Failed to sync channel from counterparty update",
    SyncValidationFailed: "Failed to validate update for sync",
    TransferNotFound: "No transfer found in storage",
    TransferNotActive: "Transfer not found in activeTransfers",
    TransferNotRegistered: "Transfer not found in activeTransfers",
};
export class LockError extends VectorError {
    constructor() {
        super(...arguments);
        this.type = VectorError.errors.LockError;
    }
}
LockError.reasons = {
    Unknown: "Unknown Lock Error //TODO",
};
export class InboundChannelUpdateError extends VectorError {
    constructor(message, update, state, context) {
        super(message, context);
        this.message = message;
        this.update = update;
        this.state = state;
        this.context = context;
        this.type = VectorError.errors.InboundChannelUpdateError;
    }
}
InboundChannelUpdateError.reasons = {
    ApplyUpdateFailed: "Failed to apply update",
    BadSignatures: "Could not recover signers",
    BadUpdateType: "Unrecognized update type",
    ChannelNotFound: "No channel found in storage",
    DifferentIdentifiers: "Update changes channel publicIdentifiers",
    DifferentChannelAddress: "Update changes channelAddress",
    InboundValidationFailed: "Failed to validate incoming update",
    InvalidAssetId: "Update `assetId` is invalid address",
    InvalidChannelAddress: "Update `channelAddress` is invalid",
    MergeUpdateFailed: "Failed to merge update",
    MessageFailed: "Failed to send message",
    RestoreNeeded: "Channel too far out of sync, must be restored",
    StaleChannel: "Channel state is behind, cannot apply update",
    StaleUpdate: "Update does not progress channel nonce",
    StaleChannelNoUpdate: "Channel nonce is behind, no latest update from counterparty",
    SaveChannelFailed: "Failed to save channel",
    SyncSingleSigned: "Counterparty gave single signed update to sync, refusing",
    SyncFailure: "Failed to sync channel from counterparty update",
    TransferNotFound: "No transfer found in storage",
};
export class NodeError extends VectorError {
    constructor(message, context) {
        super(message, context);
        this.message = message;
        this.context = context;
        this.type = VectorError.errors.NodeError;
    }
}
NodeError.reasons = {
    InternalServerError: "Failed to send request",
    InvalidParams: "Request has invalid parameters",
    MultinodeProhibitted: "Not allowed to have multiple nodes",
    NoEvts: "No evts for event",
    NoPublicIdentifier: "Public identifier not supplied, and no default identifier",
    ProviderNotFound: "Provider not available for chain",
    Timeout: "Timeout",
    TransactionNotMined: "Failed to wait for transaction to be mined",
};
export class MessagingError extends VectorError {
    constructor(message, context) {
        super(message, context);
        this.message = message;
        this.context = context;
        this.type = VectorError.errors.MessagingError;
    }
}
MessagingError.reasons = {
    Response: "Error received in response",
    Unknown: "Unknown messaging error",
};
//# sourceMappingURL=error.js.map