import { ChannelUpdate, FullChannelState, UpdateParams } from "./channel";
export declare class Result<T, Y = any> {
    private value?;
    private error?;
    isError: boolean;
    private constructor();
    getValue(): T;
    getError(): Y | undefined;
    static fail<U, Y extends Error>(error: Y): Result<U, Y>;
    static ok<T>(result: T): Result<T>;
}
export declare type Values<E> = E[keyof E];
export declare abstract class VectorError extends Error {
    readonly message: Values<typeof VectorError.reasons>;
    readonly context?: any;
    static readonly errors: {
        readonly OutboundChannelUpdateError: "OutboundChannelUpdateError";
        readonly InboundChannelUpdateError: "InboundChannelUpdateError";
        readonly ChainError: "ChainError";
        readonly ValidationError: "ValidationError";
        readonly RouterError: "RouterError";
        readonly NodeError: "NodeError";
        readonly LockError: "LockError";
        readonly MessagingError: "MessagingError";
    };
    abstract readonly type: Values<typeof VectorError.errors>;
    static readonly reasons: {
        [key: string]: string;
    };
    constructor(message: Values<typeof VectorError.reasons>, context?: any);
}
export declare class ValidationError extends VectorError {
    readonly message: Values<typeof OutboundChannelUpdateError.reasons>;
    readonly params: UpdateParams<any> | ChannelUpdate<any>;
    readonly state?: FullChannelState<any> | undefined;
    readonly context?: any;
    readonly type: "ValidationError";
    static readonly reasons: {
        readonly BadUpdateType: "Unrecognized update type";
        readonly ChannelAlreadySetup: "Channel is already setup";
        readonly ChannelNotFound: "No channel found in storage";
        readonly SetupTimeoutInvalid: "Provided state timeout is invalid";
        readonly TransferNotActive: "Transfer not found in activeTransfers";
        readonly TransferNotFound: "No transfer found in storage";
        readonly ExternalValidationFailed: "Failed external validation";
    };
    constructor(message: Values<typeof OutboundChannelUpdateError.reasons>, params: UpdateParams<any> | ChannelUpdate<any>, state?: FullChannelState<any> | undefined, context?: any);
}
export declare class OutboundChannelUpdateError extends VectorError {
    readonly message: Values<typeof OutboundChannelUpdateError.reasons>;
    readonly params: UpdateParams<any>;
    readonly state?: FullChannelState<any> | undefined;
    readonly context?: any;
    readonly type: "OutboundChannelUpdateError";
    static readonly reasons: {
        readonly ApplyUpdateFailed: "Failed to apply update";
        readonly BadSignatures: "Could not recover signers";
        readonly BadUpdateType: "Unrecognized update type";
        readonly ChannelNotFound: "No channel found in storage";
        readonly CounterpartyFailure: "Counterparty failed to apply update";
        readonly Create2Failed: "Failed to get create2 address";
        readonly InvalidParams: "Invalid params";
        readonly MessageFailed: "Failed to send message";
        readonly OutboundValidationFailed: "Requested update is invalid";
        readonly RestoreNeeded: "Channel too far out of sync, must be restored";
        readonly RegenerateUpdateFailed: "Failed to regenerate update after sync";
        readonly SaveChannelFailed: "Failed to save channel";
        readonly StaleChannelNoUpdate: "Channel nonce is behind, no latest update from counterparty";
        readonly StaleChannel: "Channel state is behind, cannot apply update";
        readonly SyncSingleSigned: "Counterparty gave single signed update to sync, refusing";
        readonly SyncFailure: "Failed to sync channel from counterparty update";
        readonly SyncValidationFailed: "Failed to validate update for sync";
        readonly TransferNotFound: "No transfer found in storage";
        readonly TransferNotActive: "Transfer not found in activeTransfers";
        readonly TransferNotRegistered: "Transfer not found in activeTransfers";
    };
    constructor(message: Values<typeof OutboundChannelUpdateError.reasons>, params: UpdateParams<any>, state?: FullChannelState<any> | undefined, context?: any);
}
export declare class LockError extends VectorError {
    readonly type: "LockError";
    static readonly reasons: {
        Unknown: string;
    };
}
export declare class InboundChannelUpdateError extends VectorError {
    readonly message: Values<typeof InboundChannelUpdateError.reasons>;
    readonly update: ChannelUpdate<any>;
    readonly state?: FullChannelState<any> | undefined;
    readonly context?: any;
    readonly type: "InboundChannelUpdateError";
    static readonly reasons: {
        readonly ApplyUpdateFailed: "Failed to apply update";
        readonly BadSignatures: "Could not recover signers";
        readonly BadUpdateType: "Unrecognized update type";
        readonly ChannelNotFound: "No channel found in storage";
        readonly DifferentIdentifiers: "Update changes channel publicIdentifiers";
        readonly DifferentChannelAddress: "Update changes channelAddress";
        readonly InboundValidationFailed: "Failed to validate incoming update";
        readonly InvalidAssetId: "Update `assetId` is invalid address";
        readonly InvalidChannelAddress: "Update `channelAddress` is invalid";
        readonly MergeUpdateFailed: "Failed to merge update";
        readonly MessageFailed: "Failed to send message";
        readonly RestoreNeeded: "Channel too far out of sync, must be restored";
        readonly StaleChannel: "Channel state is behind, cannot apply update";
        readonly StaleUpdate: "Update does not progress channel nonce";
        readonly StaleChannelNoUpdate: "Channel nonce is behind, no latest update from counterparty";
        readonly SaveChannelFailed: "Failed to save channel";
        readonly SyncSingleSigned: "Counterparty gave single signed update to sync, refusing";
        readonly SyncFailure: "Failed to sync channel from counterparty update";
        readonly TransferNotFound: "No transfer found in storage";
    };
    constructor(message: Values<typeof InboundChannelUpdateError.reasons>, update: ChannelUpdate<any>, state?: FullChannelState<any> | undefined, context?: any);
}
export declare class NodeError extends VectorError {
    readonly message: Values<typeof NodeError.reasons>;
    readonly context?: any;
    readonly type: "NodeError";
    static readonly reasons: {
        readonly InternalServerError: "Failed to send request";
        readonly InvalidParams: "Request has invalid parameters";
        readonly MultinodeProhibitted: "Not allowed to have multiple nodes";
        readonly NoEvts: "No evts for event";
        readonly NoPublicIdentifier: "Public identifier not supplied, and no default identifier";
        readonly ProviderNotFound: "Provider not available for chain";
        readonly Timeout: "Timeout";
        readonly TransactionNotMined: "Failed to wait for transaction to be mined";
    };
    constructor(message: Values<typeof NodeError.reasons>, context?: any);
}
export declare class MessagingError extends VectorError {
    readonly message: Values<typeof MessagingError.reasons>;
    readonly context?: any;
    readonly type: "MessagingError";
    static readonly reasons: {
        readonly Response: "Error received in response";
        readonly Unknown: "Unknown messaging error";
    };
    constructor(message: Values<typeof MessagingError.reasons>, context?: any);
}
//# sourceMappingURL=error.d.ts.map