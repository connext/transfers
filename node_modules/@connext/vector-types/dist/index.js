'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ethers = require('ethers');
var typebox = require('@sinclair/typebox');

const JsonRpcProvider = ethers.providers.JsonRpcProvider;

class Result {
    constructor(error, value) {
        if (error) {
            this.isError = true;
            this.error = error;
        }
        else {
            this.isError = false;
            this.value = value;
        }
    }
    getValue() {
        if (this.isError) {
            throw new Error(`Can't getValue() of error result: ${this.error}`);
        }
        return this.value;
    }
    getError() {
        if (this.isError) {
            return this.error;
        }
        return undefined;
    }
    static fail(error) {
        return new Result(error);
    }
    static ok(result) {
        return new Result(undefined, result);
    }
}
class VectorError extends Error {
    constructor(message, context) {
        super(message);
        this.message = message;
        this.context = context;
    }
}
VectorError.errors = {
    OutboundChannelUpdateError: "OutboundChannelUpdateError",
    InboundChannelUpdateError: "InboundChannelUpdateError",
    ChainError: "ChainError",
    ValidationError: "ValidationError",
    RouterError: "RouterError",
    NodeError: "NodeError",
    LockError: "LockError",
    MessagingError: "MessagingError",
};
class ValidationError extends VectorError {
    constructor(message, params, state, context) {
        super(message, context);
        this.message = message;
        this.params = params;
        this.state = state;
        this.context = context;
        this.type = VectorError.errors.ValidationError;
    }
}
ValidationError.reasons = {
    BadUpdateType: "Unrecognized update type",
    ChannelAlreadySetup: "Channel is already setup",
    ChannelNotFound: "No channel found in storage",
    SetupTimeoutInvalid: "Provided state timeout is invalid",
    TransferNotActive: "Transfer not found in activeTransfers",
    TransferNotFound: "No transfer found in storage",
    ExternalValidationFailed: "Failed external validation",
};
class OutboundChannelUpdateError extends VectorError {
    constructor(message, params, state, context) {
        super(message, context);
        this.message = message;
        this.params = params;
        this.state = state;
        this.context = context;
        this.type = VectorError.errors.OutboundChannelUpdateError;
    }
}
OutboundChannelUpdateError.reasons = {
    ApplyUpdateFailed: "Failed to apply update",
    BadSignatures: "Could not recover signers",
    BadUpdateType: "Unrecognized update type",
    ChannelNotFound: "No channel found in storage",
    CounterpartyFailure: "Counterparty failed to apply update",
    Create2Failed: "Failed to get create2 address",
    InvalidParams: "Invalid params",
    MessageFailed: "Failed to send message",
    OutboundValidationFailed: "Requested update is invalid",
    RestoreNeeded: "Channel too far out of sync, must be restored",
    RegenerateUpdateFailed: "Failed to regenerate update after sync",
    SaveChannelFailed: "Failed to save channel",
    StaleChannelNoUpdate: "Channel nonce is behind, no latest update from counterparty",
    StaleChannel: "Channel state is behind, cannot apply update",
    SyncSingleSigned: "Counterparty gave single signed update to sync, refusing",
    SyncFailure: "Failed to sync channel from counterparty update",
    SyncValidationFailed: "Failed to validate update for sync",
    TransferNotFound: "No transfer found in storage",
    TransferNotActive: "Transfer not found in activeTransfers",
    TransferNotRegistered: "Transfer not found in activeTransfers",
};
class LockError extends VectorError {
    constructor() {
        super(...arguments);
        this.type = VectorError.errors.LockError;
    }
}
LockError.reasons = {
    Unknown: "Unknown Lock Error //TODO",
};
class InboundChannelUpdateError extends VectorError {
    constructor(message, update, state, context) {
        super(message, context);
        this.message = message;
        this.update = update;
        this.state = state;
        this.context = context;
        this.type = VectorError.errors.InboundChannelUpdateError;
    }
}
InboundChannelUpdateError.reasons = {
    ApplyUpdateFailed: "Failed to apply update",
    BadSignatures: "Could not recover signers",
    BadUpdateType: "Unrecognized update type",
    ChannelNotFound: "No channel found in storage",
    DifferentIdentifiers: "Update changes channel publicIdentifiers",
    DifferentChannelAddress: "Update changes channelAddress",
    InboundValidationFailed: "Failed to validate incoming update",
    InvalidAssetId: "Update `assetId` is invalid address",
    InvalidChannelAddress: "Update `channelAddress` is invalid",
    MergeUpdateFailed: "Failed to merge update",
    MessageFailed: "Failed to send message",
    RestoreNeeded: "Channel too far out of sync, must be restored",
    StaleChannel: "Channel state is behind, cannot apply update",
    StaleUpdate: "Update does not progress channel nonce",
    StaleChannelNoUpdate: "Channel nonce is behind, no latest update from counterparty",
    SaveChannelFailed: "Failed to save channel",
    SyncSingleSigned: "Counterparty gave single signed update to sync, refusing",
    SyncFailure: "Failed to sync channel from counterparty update",
    TransferNotFound: "No transfer found in storage",
};
class NodeError extends VectorError {
    constructor(message, context) {
        super(message, context);
        this.message = message;
        this.context = context;
        this.type = VectorError.errors.NodeError;
    }
}
NodeError.reasons = {
    InternalServerError: "Failed to send request",
    InvalidParams: "Request has invalid parameters",
    MultinodeProhibitted: "Not allowed to have multiple nodes",
    NoEvts: "No evts for event",
    NoPublicIdentifier: "Public identifier not supplied, and no default identifier",
    ProviderNotFound: "Provider not available for chain",
    Timeout: "Timeout",
    TransactionNotMined: "Failed to wait for transaction to be mined",
};
class MessagingError extends VectorError {
    constructor(message, context) {
        super(message, context);
        this.message = message;
        this.context = context;
        this.type = VectorError.errors.MessagingError;
    }
}
MessagingError.reasons = {
    Response: "Error received in response",
    Unknown: "Unknown messaging error",
};

const ERC20Abi = [
    "function balanceOf(address owner) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)",
    "function totalSupply() external view returns (uint256)",
    "function allowance(address owner, address spender) external view returns (uint256)",
    "function approve(address spender, uint256 amount) external returns (bool)",
    "function transfer(address to, uint amount) returns (boolean)",
    "function transferFrom(address sender, address recipient, uint256 amount) external returns (bool)",
    "event Transfer(address indexed from, address indexed to, uint amount)",
    "event Approval(address indexed owner, address indexed spender, uint256 value)",
];
class ChainError extends VectorError {
    constructor(message, context = {}) {
        super(message);
        this.message = message;
        this.context = context;
        this.type = VectorError.errors.ChainError;
        this.canRetry = Object.values(ChainError.retryableTxErrors).includes(this.message);
    }
}
ChainError.reasons = {
    ProviderNotFound: "Provider not found for chainId",
    SignerNotFound: "Signer not found for chainId",
    SenderNotInChannel: "Sender is not a channel participant",
    NotEnoughFunds: "Not enough funds in wallet",
    FailedToSendTx: "Failed to send transaction to chain",
    TransferNotRegistered: "Transfer not in registry",
    MissingSigs: "Channel state is not double signed",
    ResolverNeeded: "Transfer resolver must be provided in dispute",
    NotInitialState: "Transfer must be disputed with initial state",
};
ChainError.retryableTxErrors = {
    BadNonce: "the tx doesn't have the correct nonce",
    InvalidNonce: "Invalid nonce",
    MissingHash: "no transaction hash found in tx response",
    UnderpricedReplancement: "replacement transaction underpriced",
};

const enumify = (x) => x;
const tidy = (str) => `${str.replace(/\n/g, "").replace(/ +/g, " ")}`;

const BalanceEncoding = tidy(`tuple(
    uint256[2] amount,
    address[2] to
  )`);

const UpdateType = {
    create: "create",
    deposit: "deposit",
    resolve: "resolve",
    setup: "setup",
};
const CoreChannelStateEncoding = tidy(`tuple(
  address channelAddress,
  address alice,
  address bob,
  address[] assetIds,
  ${BalanceEncoding}[] balances,
  uint256[] processedDepositsA,
  uint256[] processedDepositsB,
  uint256 timeout,
  uint256 nonce,
  bytes32 merkleRoot,
  uint256 defundNonce
)`);
const CoreTransferStateEncoding = tidy(`tuple(
  address channelAddress,
  bytes32 transferId,
  address transferDefinition,
  address initiator,
  address responder,
  address assetId,
  ${BalanceEncoding} balance,
  uint256 transferTimeout,
  bytes32 initialStateHash
)`);

const DEFAULT_TRANSFER_TIMEOUT = 8640;
const MINIMUM_TRANSFER_TIMEOUT = DEFAULT_TRANSFER_TIMEOUT / 2;
const TRANSFER_DECREMENT = 432;

const SETUP_EVENT = "SETUP";
const CONDITIONAL_TRANSFER_CREATED_EVENT = "CONDITIONAL_TRANSFER_CREATED";
const CONDITIONAL_TRANSFER_RESOLVED_EVENT = "CONDITIONAL_TRANSFER_RESOLVED";
const DEPOSIT_RECONCILED_EVENT = "DEPOSIT_RECONCILED";
const REQUEST_COLLATERAL_EVENT = "REQUEST_COLLATERAL";
const WITHDRAWAL_CREATED_EVENT = "WITHDRAWAL_CREATED";
const WITHDRAWAL_RESOLVED_EVENT = "WITHDRAWAL_RESOLVED";
const WITHDRAWAL_RECONCILED_EVENT = "WITHDRAWAL_RECONCILED";
const EngineEvents = {
    [SETUP_EVENT]: SETUP_EVENT,
    [CONDITIONAL_TRANSFER_CREATED_EVENT]: CONDITIONAL_TRANSFER_CREATED_EVENT,
    [CONDITIONAL_TRANSFER_RESOLVED_EVENT]: CONDITIONAL_TRANSFER_RESOLVED_EVENT,
    [DEPOSIT_RECONCILED_EVENT]: DEPOSIT_RECONCILED_EVENT,
    [REQUEST_COLLATERAL_EVENT]: REQUEST_COLLATERAL_EVENT,
    [WITHDRAWAL_CREATED_EVENT]: WITHDRAWAL_CREATED_EVENT,
    [WITHDRAWAL_RESOLVED_EVENT]: WITHDRAWAL_RESOLVED_EVENT,
    [WITHDRAWAL_RECONCILED_EVENT]: WITHDRAWAL_RECONCILED_EVENT,
};

const ProtocolEventName = {
    CHANNEL_UPDATE_EVENT: "CHANNEL_UPDATE_EVENT",
};

const TAddress = typebox.Type.Pattern(/^0x[a-fA-F0-9]{40}$/);
const TIntegerString = typebox.Type.Pattern(/^([0-9])*$/);
const TDecimalString = typebox.Type.Pattern(/^[0-9]*\.?[0-9]*$/);
const TPublicIdentifier = typebox.Type.Pattern(/^indra([a-zA-Z0-9]{50})$/);
const TBytes32 = typebox.Type.Pattern(/^0x([a-fA-F0-9]{64})$/);
const TBytes = typebox.Type.Pattern(/^0x([a-fA-F0-9])$/);
const TSignature = typebox.Type.Pattern(/^0x([a-fA-F0-9]{130})$/);
const TUrl = typebox.Type.String({ format: "uri" });
const TChainId = typebox.Type.Number({ minimum: 1 });
const TBalance = typebox.Type.Object({
    to: typebox.Type.Array(TAddress),
    amount: typebox.Type.Array(TIntegerString),
});
const TBasicMeta = typebox.Type.Optional(typebox.Type.Any());
const TContractAddresses = typebox.Type.Object({
    channelFactoryAddress: TAddress,
    channelMastercopyAddress: TAddress,
    transferRegistryAddress: TAddress,
});
const TNetworkContext = typebox.Type.Intersect([
    TContractAddresses,
    typebox.Type.Object({
        chainId: TChainId,
        providerUrl: TUrl,
    }),
]);
const TransferStateSchema = typebox.Type.Any();
const TransferResolverSchema = typebox.Type.Any();
const TransferEncodingSchema = typebox.Type.Array(typebox.Type.String(), { maxItems: 2, minItems: 2, uniqueItems: true });
const TransferNameSchema = typebox.Type.String();
const TFullTransferState = typebox.Type.Object({
    balance: TBalance,
    assetId: TAddress,
    channelAddress: TAddress,
    transferId: TBytes32,
    transferDefinition: TAddress,
    transferTimeout: TIntegerString,
    initialStateHash: TBytes32,
    initiator: TAddress,
    responder: TAddress,
    channelFactoryAddress: TAddress,
    chainId: TChainId,
    transferEncodings: TransferEncodingSchema,
    transferState: TransferStateSchema,
    transferResolver: typebox.Type.Optional(typebox.Type.Any()),
    meta: TBasicMeta,
});
const TSetupUpdateDetails = typebox.Type.Object({
    timeout: TIntegerString,
    networkContext: TNetworkContext,
});
const TDepositUpdateDetails = typebox.Type.Object({
    totalDepositsAlice: TIntegerString,
    totalDepositsBob: TIntegerString,
});
const TCreateUpdateDetails = typebox.Type.Object({
    transferId: TBytes32,
    balance: TBalance,
    transferDefinition: TAddress,
    transferTimeout: TIntegerString,
    transferInitialState: TransferStateSchema,
    merkleProofData: typebox.Type.Array(TBytes),
    merkleRoot: TBytes32,
    meta: TBasicMeta,
});
const TResolveUpdateDetails = typebox.Type.Object({
    transferId: TBytes32,
    transferDefinition: TAddress,
    transferResolver: TransferResolverSchema,
    merkleRoot: TBytes32,
    meta: TBasicMeta,
});
const TChannelUpdateDetails = typebox.Type.Union([
    TSetupUpdateDetails,
    TDepositUpdateDetails,
    TCreateUpdateDetails,
    TResolveUpdateDetails,
]);
const TChannelUpdateType = typebox.Type.Union(Object.values(UpdateType).map(update => typebox.Type.Literal(update)));
const TChannelUpdate = typebox.Type.Object({
    channelAddress: TAddress,
    fromIdentifier: TPublicIdentifier,
    toIdentifier: TPublicIdentifier,
    type: TChannelUpdateType,
    nonce: typebox.Type.Number(),
    balance: TBalance,
    assetId: TAddress,
    details: TCreateUpdateDetails,
    aliceSignature: typebox.Type.Optional(TSignature),
    bobSignature: typebox.Type.Optional(TSignature),
});
const TFullChannelState = typebox.Type.Object({
    assetIds: typebox.Type.Array(TAddress, { minItems: 1 }),
    balances: typebox.Type.Array(TBalance, { minItems: 1 }),
    channelAddress: TAddress,
    alice: TAddress,
    bob: TAddress,
    merkleRoot: TBytes,
    nonce: typebox.Type.Number(),
    processedDepositsA: typebox.Type.Array(TIntegerString),
    processedDepositsB: typebox.Type.Array(TIntegerString),
    timeout: TIntegerString,
    aliceIdentifier: TPublicIdentifier,
    bobIdentifier: TPublicIdentifier,
    latestUpdate: TChannelUpdate,
    networkContext: TNetworkContext,
});

const VectorNodeConfigSchema = typebox.Type.Object({
    adminToken: typebox.Type.String(),
    authUrl: typebox.Type.Optional(typebox.Type.String({ format: "uri" })),
    chainAddresses: typebox.Type.Map(TContractAddresses),
    chainProviders: typebox.Type.Map(TUrl),
    dbUrl: typebox.Type.Optional(TUrl),
    logLevel: typebox.Type.Optional(typebox.Type.Union([
        typebox.Type.Literal("fatal"),
        typebox.Type.Literal("error"),
        typebox.Type.Literal("warn"),
        typebox.Type.Literal("info"),
        typebox.Type.Literal("debug"),
        typebox.Type.Literal("trace"),
        typebox.Type.Literal("silent"),
    ])),
    messagingUrl: typebox.Type.Optional(TUrl),
    mnemonic: typebox.Type.Optional(typebox.Type.String()),
    natsUrl: typebox.Type.Optional(TUrl),
});

const ChannelRpcMethods = {
    chan_getChannelState: "chan_getChannelState",
    chan_getChannelStateByParticipants: "chan_getChannelStateByParticipants",
    chan_getChannelStates: "chan_getChannelStates",
    chan_getTransferStateByRoutingId: "chan_getTransferStateByRoutingId",
    chan_getTransferStatesByRoutingId: "chan_getTransferStatesByRoutingId",
    chan_getActiveTransfers: "chan_getActiveTransfers",
    chan_getTransferState: "chan_getTransferState",
    chan_setup: "chan_setup",
    chan_requestSetup: "chan_requestSetup",
    chan_deposit: "chan_deposit",
    chan_requestCollateral: "chan_requestCollateral",
    chan_createTransfer: "chan_createTransfer",
    chan_resolveTransfer: "chan_resolveTransfer",
    chan_withdraw: "chan_withdraw",
};

const GetTransferStateByRoutingIdParamsSchema = typebox.Type.Object({
    channelAddress: TAddress,
    routingId: TBytes32,
});
const GetTransferStatesByRoutingIdParamsSchema = typebox.Type.Object({
    routingId: TBytes32,
});
const GetChannelStateParamsSchema = typebox.Type.Object({ channelAddress: TAddress });
const GetChannelStatesParamsSchema = typebox.Type.Object({});
const GetChannelStateByParticipantsParamsSchema = typebox.Type.Object({
    alice: TPublicIdentifier,
    bob: TPublicIdentifier,
    chainId: TChainId,
});
const GetActiveTransfersParamsSchema = typebox.Type.Object({
    channelAddress: TAddress,
});
const GetTransferStateParamsSchema = typebox.Type.Object({
    transferId: TBytes32,
});
const SetupEngineParamsSchema = typebox.Type.Object({
    counterpartyIdentifier: TPublicIdentifier,
    chainId: TChainId,
    timeout: TIntegerString,
    meta: TBasicMeta,
});
const DepositEngineParamsSchema = typebox.Type.Object({
    channelAddress: TAddress,
    assetId: TAddress,
    meta: TBasicMeta,
});
const RequestCollateralEngineParamsSchema = typebox.Type.Object({
    channelAddress: TAddress,
    assetId: TAddress,
    amount: typebox.Type.Optional(TIntegerString),
});
const CreateConditionalTransferParamsSchema = typebox.Type.Object({
    channelAddress: TAddress,
    amount: TIntegerString,
    assetId: TAddress,
    recipient: typebox.Type.Optional(TPublicIdentifier),
    recipientChainId: typebox.Type.Optional(TChainId),
    recipientAssetId: typebox.Type.Optional(TAddress),
    timeout: typebox.Type.Optional(TIntegerString),
    meta: TBasicMeta,
    type: typebox.Type.String(),
    details: typebox.Type.Any(),
});
const ResolveTransferParamsSchema = typebox.Type.Object({
    channelAddress: TAddress,
    transferId: TBytes32,
    meta: TBasicMeta,
    transferResolver: TransferResolverSchema,
});
const WithdrawParamsSchema = typebox.Type.Object({
    channelAddress: TAddress,
    amount: TIntegerString,
    assetId: TAddress,
    recipient: TAddress,
    fee: typebox.Type.Optional(TIntegerString),
    meta: TBasicMeta,
});
const RpcRequestEngineParamsSchema = typebox.Type.Object({
    id: typebox.Type.Number({ minimum: 1 }),
    jsonrpc: typebox.Type.Literal("2.0"),
    method: typebox.Type.Union(Object.values(ChannelRpcMethods).map(methodName => typebox.Type.Literal(methodName))),
    params: typebox.Type.Optional(typebox.Type.Any()),
});
(function (EngineParams) {
    EngineParams.RpcRequestSchema = RpcRequestEngineParamsSchema;
    EngineParams.GetTransferStateByRoutingIdSchema = GetTransferStateByRoutingIdParamsSchema;
    EngineParams.GetTransferStatesByRoutingIdSchema = GetTransferStatesByRoutingIdParamsSchema;
    EngineParams.GetChannelStatesSchema = GetChannelStatesParamsSchema;
    EngineParams.GetChannelStateSchema = GetChannelStateParamsSchema;
    EngineParams.GetChannelStateByParticipantsSchema = GetChannelStateByParticipantsParamsSchema;
    EngineParams.GetActiveTransfersSchema = GetActiveTransfersParamsSchema;
    EngineParams.GetTransferStateSchema = GetTransferStateParamsSchema;
    EngineParams.SetupSchema = SetupEngineParamsSchema;
    EngineParams.DepositSchema = DepositEngineParamsSchema;
    EngineParams.RequestCollateralSchema = RequestCollateralEngineParamsSchema;
    EngineParams.ConditionalTransferSchema = CreateConditionalTransferParamsSchema;
    EngineParams.ResolveTransferSchema = ResolveTransferParamsSchema;
    EngineParams.WithdrawSchema = WithdrawParamsSchema;
})(exports.EngineParams || (exports.EngineParams = {}));

const SetupProtocolParamsSchema = typebox.Type.Intersect([
    TSetupUpdateDetails,
    typebox.Type.Object({ counterpartyIdentifier: TPublicIdentifier, meta: TBasicMeta }),
]);
const DepositProtocolParamsSchema = typebox.Type.Object({
    channelAddress: TAddress,
    assetId: TAddress,
    meta: TBasicMeta,
});
const CreateProtocolParamsSchema = typebox.Type.Object({
    channelAddress: TAddress,
    balance: TBalance,
    assetId: TAddress,
    transferDefinition: TAddress,
    transferInitialState: TransferStateSchema,
    timeout: TIntegerString,
    meta: TBasicMeta,
});
const ResolveProtocolParamsSchema = typebox.Type.Object({
    channelAddress: TAddress,
    transferId: TBytes32,
    transferResolver: TransferResolverSchema,
    meta: TBasicMeta,
});
(function (ProtocolParams) {
    ProtocolParams.SetupSchema = SetupProtocolParamsSchema;
    ProtocolParams.DepositSchema = DepositProtocolParamsSchema;
    ProtocolParams.CreateSchema = CreateProtocolParamsSchema;
    ProtocolParams.ResolveSchema = ResolveProtocolParamsSchema;
})(exports.ProtocolParams || (exports.ProtocolParams = {}));

const TPathSchema = typebox.Type.Object({
    recipient: TPublicIdentifier,
    recipientChainId: TChainId,
    recipientAssetId: TAddress,
});
const TRoutingMeta = typebox.Type.Object({
    routingId: TBytes32,
    requireOnline: typebox.Type.Boolean(),
    path: typebox.Type.Array(TPathSchema),
});
(function (RouterSchemas) {
    RouterSchemas.RouterMeta = TRoutingMeta;
})(exports.RouterSchemas || (exports.RouterSchemas = {}));

const BasicChannelServerResponseSchema = {
    200: typebox.Type.Object({
        channelAddress: TAddress,
    }),
};
const BasicTransferServerResponseSchema = {
    200: typebox.Type.Object({
        channelAddress: TAddress,
        transferId: TBytes32,
        routingId: typebox.Type.Optional(TBytes32),
    }),
};
const GetTransferStateByRoutingIdParamsSchema$1 = typebox.Type.Intersect([
    exports.EngineParams.GetTransferStateByRoutingIdSchema,
    typebox.Type.Object({
        publicIdentifier: TPublicIdentifier,
    }),
]);
const GetTransferStateByRoutingIdResponseSchema = {
    200: typebox.Type.Union([typebox.Type.Undefined, TFullTransferState]),
};
const GetTransferStatesByRoutingIdParamsSchema$1 = typebox.Type.Intersect([
    exports.EngineParams.GetTransferStatesByRoutingIdSchema,
    typebox.Type.Object({
        publicIdentifier: TPublicIdentifier,
    }),
]);
const GetTransferStatesByRoutingIdResponseSchema = {
    200: typebox.Type.Array(TFullTransferState),
};
const GetActiveTransfersByChannelAddressParamsSchema = typebox.Type.Intersect([
    exports.EngineParams.GetActiveTransfersSchema,
    typebox.Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const GetActiveTransfersByChannelAddressResponseSchema = {
    200: typebox.Type.Array(TFullTransferState),
};
const GetTransferStateParamsSchema$1 = typebox.Type.Intersect([
    exports.EngineParams.GetTransferStateSchema,
    typebox.Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const GetTransferStateResponseSchema = {
    200: typebox.Type.Union([typebox.Type.Undefined, TFullTransferState]),
};
const GetChannelStateParamsSchema$1 = typebox.Type.Intersect([
    exports.EngineParams.GetChannelStateSchema,
    typebox.Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const GetChannelStateResponseSchema = {
    200: typebox.Type.Union([typebox.Type.Undefined, TFullChannelState]),
};
const GetChannelStatesParamsSchema$1 = typebox.Type.Intersect([
    exports.EngineParams.GetChannelStatesSchema,
    typebox.Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const GetChannelStatesResponseSchema = {
    200: typebox.Type.Array(TAddress),
};
const GetChannelStateByParticipantsParamsSchema$1 = typebox.Type.Object({
    publicIdentifier: TPublicIdentifier,
    counterparty: TPublicIdentifier,
    chainId: TChainId,
});
const GetChannelStateByParticipantsResponseSchema = GetChannelStateResponseSchema;
const GetConfigResponseSchema = {
    200: typebox.Type.Array(typebox.Type.Object({
        publicIdentifier: TPublicIdentifier,
        signerAddress: TAddress,
        index: typebox.Type.Integer(),
    })),
};
const GetListenerParamsSchema = typebox.Type.Object({
    eventName: typebox.Type.Union(Object.values(EngineEvents).map(e => typebox.Type.Literal(e))),
    publicIdentifier: TPublicIdentifier,
});
const GetListenerResponseSchema = {
    200: typebox.Type.Object({ url: TUrl }),
};
const GetListenersParamsSchema = typebox.Type.Object({ publicIdentifier: TPublicIdentifier });
const GetListenersResponseSchema = {
    200: typebox.Type.Map(TUrl),
};
const PostRegisterListenerBodySchema = typebox.Type.Object({
    publicIdentifier: TPublicIdentifier,
    events: typebox.Type.Map(typebox.Type.String()),
});
const PostRegisterListenerResponseSchema = {
    200: typebox.Type.Object({
        message: typebox.Type.String(),
    }),
};
const PostSetupBodySchema = typebox.Type.Intersect([
    exports.EngineParams.SetupSchema,
    typebox.Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostSetupResponseSchema = BasicChannelServerResponseSchema;
const PostRequestSetupBodySchema = PostSetupBodySchema;
const PostRequestSetupResponseSchema = BasicChannelServerResponseSchema;
const PostDepositBodySchema = typebox.Type.Intersect([
    exports.EngineParams.DepositSchema,
    typebox.Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostDepositResponseSchema = BasicChannelServerResponseSchema;
const PostRequestCollateralBodySchema = typebox.Type.Intersect([
    exports.EngineParams.RequestCollateralSchema,
    typebox.Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostRequestCollateralResponseSchema = BasicChannelServerResponseSchema;
const PostSendDepositTxBodySchema = typebox.Type.Object({
    channelAddress: TAddress,
    amount: TIntegerString,
    assetId: TAddress,
    chainId: TChainId,
    publicIdentifier: TPublicIdentifier,
});
const PostSendDepositTxResponseSchema = {
    200: typebox.Type.Object({
        txHash: TBytes32,
    }),
};
const PostConditionalTransferBodySchema = typebox.Type.Intersect([
    exports.EngineParams.ConditionalTransferSchema,
    typebox.Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostConditionalTransferResponseSchema = BasicTransferServerResponseSchema;
const PostResolveTransferBodySchema = typebox.Type.Intersect([
    exports.EngineParams.ResolveTransferSchema,
    typebox.Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostResolveTransferResponseSchema = BasicTransferServerResponseSchema;
const PostWithdrawTransferBodySchema = typebox.Type.Intersect([
    exports.EngineParams.WithdrawSchema,
    typebox.Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostWithdrawTransferResponseSchema = {
    200: typebox.Type.Object({
        channelAddress: TAddress,
        transferId: TBytes32,
        transactionHash: typebox.Type.Optional(TBytes32),
    }),
};
const PostCreateNodeBodySchema = typebox.Type.Object({
    index: typebox.Type.Integer({ minimum: 0, maximum: 2147483647 }),
    mnemonic: typebox.Type.Optional(typebox.Type.String()),
});
const PostCreateNodeResponseSchema = {
    200: typebox.Type.Object({
        publicIdentifier: TPublicIdentifier,
        signerAddress: TAddress,
        index: typebox.Type.Integer(),
    }),
};
const PostAdminBodySchema = typebox.Type.Object({
    adminToken: typebox.Type.String({
        example: "cxt1234",
        description: "Admin token",
    }),
});
const PostAdminResponseSchema = {
    200: typebox.Type.Object({
        message: typebox.Type.String(),
    }),
};
(function (ServerNodeParams) {
    ServerNodeParams.GetTransferStateByRoutingIdSchema = GetTransferStateByRoutingIdParamsSchema$1;
    ServerNodeParams.GetTransferStatesByRoutingIdSchema = GetTransferStatesByRoutingIdParamsSchema$1;
    ServerNodeParams.GetTransferStateSchema = GetTransferStateParamsSchema$1;
    ServerNodeParams.GetActiveTransfersByChannelAddressSchema = GetActiveTransfersByChannelAddressParamsSchema;
    ServerNodeParams.GetChannelStateSchema = GetChannelStateParamsSchema$1;
    ServerNodeParams.GetChannelStatesSchema = GetChannelStatesParamsSchema$1;
    ServerNodeParams.GetChannelStateByParticipantsSchema = GetChannelStateByParticipantsParamsSchema$1;
    ServerNodeParams.GetListenerSchema = GetListenerParamsSchema;
    ServerNodeParams.GetListenersSchema = GetListenersParamsSchema;
    ServerNodeParams.GetConfigSchema = typebox.Type.Object({});
    ServerNodeParams.SetupSchema = PostSetupBodySchema;
    ServerNodeParams.RequestSetupSchema = PostRequestSetupBodySchema;
    ServerNodeParams.DepositSchema = PostDepositBodySchema;
    ServerNodeParams.RequestCollateralSchema = PostRequestCollateralBodySchema;
    ServerNodeParams.SendDepositTxSchema = PostSendDepositTxBodySchema;
    ServerNodeParams.ConditionalTransferSchema = PostConditionalTransferBodySchema;
    ServerNodeParams.ResolveTransferSchema = PostResolveTransferBodySchema;
    ServerNodeParams.WithdrawSchema = PostWithdrawTransferBodySchema;
    ServerNodeParams.RegisterListenerSchema = PostRegisterListenerBodySchema;
    ServerNodeParams.AdminSchema = PostAdminBodySchema;
    ServerNodeParams.CreateNodeSchema = PostCreateNodeBodySchema;
})(exports.ServerNodeParams || (exports.ServerNodeParams = {}));
(function (ServerNodeResponses) {
    ServerNodeResponses.GetTransferStateByRoutingIdSchema = GetTransferStateByRoutingIdResponseSchema;
    ServerNodeResponses.GetTransferStatesByRoutingIdSchema = GetTransferStatesByRoutingIdResponseSchema;
    ServerNodeResponses.GetTransferStateSchema = GetTransferStateResponseSchema;
    ServerNodeResponses.GetActiveTransfersByChannelAddressSchema = GetActiveTransfersByChannelAddressResponseSchema;
    ServerNodeResponses.GetChannelStateSchema = GetChannelStateResponseSchema;
    ServerNodeResponses.GetChannelStateByParticipantsSchema = GetChannelStateByParticipantsResponseSchema;
    ServerNodeResponses.GetChannelStatesSchema = GetChannelStatesResponseSchema;
    ServerNodeResponses.GetListenerSchema = GetListenerResponseSchema;
    ServerNodeResponses.GetListenersSchema = GetListenersResponseSchema;
    ServerNodeResponses.GetConfigSchema = GetConfigResponseSchema;
    ServerNodeResponses.SetupSchema = PostSetupResponseSchema;
    ServerNodeResponses.RequestSetupSchema = PostRequestSetupResponseSchema;
    ServerNodeResponses.DepositSchema = PostDepositResponseSchema;
    ServerNodeResponses.RequestCollateralSchema = PostRequestCollateralResponseSchema;
    ServerNodeResponses.SendDepositTxSchema = PostSendDepositTxResponseSchema;
    ServerNodeResponses.ConditionalTransferSchema = PostConditionalTransferResponseSchema;
    ServerNodeResponses.ResolveTransferSchema = PostResolveTransferResponseSchema;
    ServerNodeResponses.WithdrawSchema = PostWithdrawTransferResponseSchema;
    ServerNodeResponses.RegisterListenerSchema = PostRegisterListenerResponseSchema;
    ServerNodeResponses.AdminSchema = PostAdminResponseSchema;
    ServerNodeResponses.CreateNodeSchema = PostCreateNodeResponseSchema;
})(exports.ServerNodeResponses || (exports.ServerNodeResponses = {}));

const StoredTransactionStatus = {
    submitted: "submitted",
    mined: "mined",
    failed: "failed",
};
const TransactionReason = {
    allowance: "allowance",
    approveTokens: "approveTokens",
    disputeChannel: "disputeChannel",
    disputeTransfer: "disputeTransfer",
    defundChannel: "defundChannel",
    defundTransfer: "defundTransfer",
    depositA: "depositA",
    depositB: "depositB",
    deployWithDepositA: "deployWithDepositA",
    transferTokens: "transferTokens",
    withdraw: "withdraw",
};

const HashlockTransferName = "HashlockTransfer";
const HashlockTransferStateEncoding = tidy(`tuple(
    bytes32 lockHash,
    uint256 expiry
  )`);
const HashlockTransferResolverEncoding = tidy(`tuple(
    bytes32 preImage
  )`);

const WithdrawName = "Withdraw";
const WithdrawStateEncoding = tidy(`tuple(
    bytes initiatorSignature,
    address initiator,
    address responder,
    bytes32 data,
    uint256 nonce,
    uint256 fee
  )`);
const WithdrawResolverEncoding = tidy(`tuple(
    bytes responderSignature
  )`);

const TransferNames = {
    [HashlockTransferName]: HashlockTransferName,
    [WithdrawName]: WithdrawName,
};
const TransferEncodingsMap = {
    [HashlockTransferName]: [HashlockTransferStateEncoding, HashlockTransferResolverEncoding],
    [WithdrawName]: [WithdrawStateEncoding, WithdrawResolverEncoding],
};

Object.defineProperty(exports, 'Contract', {
  enumerable: true,
  get: function () {
    return ethers.Contract;
  }
});
exports.BalanceEncoding = BalanceEncoding;
exports.CONDITIONAL_TRANSFER_CREATED_EVENT = CONDITIONAL_TRANSFER_CREATED_EVENT;
exports.CONDITIONAL_TRANSFER_RESOLVED_EVENT = CONDITIONAL_TRANSFER_RESOLVED_EVENT;
exports.ChainError = ChainError;
exports.ChannelRpcMethods = ChannelRpcMethods;
exports.CoreChannelStateEncoding = CoreChannelStateEncoding;
exports.CoreTransferStateEncoding = CoreTransferStateEncoding;
exports.DEFAULT_TRANSFER_TIMEOUT = DEFAULT_TRANSFER_TIMEOUT;
exports.DEPOSIT_RECONCILED_EVENT = DEPOSIT_RECONCILED_EVENT;
exports.ERC20Abi = ERC20Abi;
exports.EngineEvents = EngineEvents;
exports.HashlockTransferName = HashlockTransferName;
exports.HashlockTransferResolverEncoding = HashlockTransferResolverEncoding;
exports.HashlockTransferStateEncoding = HashlockTransferStateEncoding;
exports.InboundChannelUpdateError = InboundChannelUpdateError;
exports.JsonRpcProvider = JsonRpcProvider;
exports.LockError = LockError;
exports.MINIMUM_TRANSFER_TIMEOUT = MINIMUM_TRANSFER_TIMEOUT;
exports.MessagingError = MessagingError;
exports.NodeError = NodeError;
exports.OutboundChannelUpdateError = OutboundChannelUpdateError;
exports.ProtocolEventName = ProtocolEventName;
exports.REQUEST_COLLATERAL_EVENT = REQUEST_COLLATERAL_EVENT;
exports.Result = Result;
exports.SETUP_EVENT = SETUP_EVENT;
exports.StoredTransactionStatus = StoredTransactionStatus;
exports.TAddress = TAddress;
exports.TBalance = TBalance;
exports.TBasicMeta = TBasicMeta;
exports.TBytes = TBytes;
exports.TBytes32 = TBytes32;
exports.TChainId = TChainId;
exports.TChannelUpdate = TChannelUpdate;
exports.TChannelUpdateDetails = TChannelUpdateDetails;
exports.TChannelUpdateType = TChannelUpdateType;
exports.TContractAddresses = TContractAddresses;
exports.TCreateUpdateDetails = TCreateUpdateDetails;
exports.TDecimalString = TDecimalString;
exports.TDepositUpdateDetails = TDepositUpdateDetails;
exports.TFullChannelState = TFullChannelState;
exports.TFullTransferState = TFullTransferState;
exports.TIntegerString = TIntegerString;
exports.TNetworkContext = TNetworkContext;
exports.TPublicIdentifier = TPublicIdentifier;
exports.TRANSFER_DECREMENT = TRANSFER_DECREMENT;
exports.TResolveUpdateDetails = TResolveUpdateDetails;
exports.TSetupUpdateDetails = TSetupUpdateDetails;
exports.TSignature = TSignature;
exports.TUrl = TUrl;
exports.TransactionReason = TransactionReason;
exports.TransferEncodingSchema = TransferEncodingSchema;
exports.TransferEncodingsMap = TransferEncodingsMap;
exports.TransferNameSchema = TransferNameSchema;
exports.TransferNames = TransferNames;
exports.TransferResolverSchema = TransferResolverSchema;
exports.TransferStateSchema = TransferStateSchema;
exports.UpdateType = UpdateType;
exports.ValidationError = ValidationError;
exports.VectorError = VectorError;
exports.VectorNodeConfigSchema = VectorNodeConfigSchema;
exports.WITHDRAWAL_CREATED_EVENT = WITHDRAWAL_CREATED_EVENT;
exports.WITHDRAWAL_RECONCILED_EVENT = WITHDRAWAL_RECONCILED_EVENT;
exports.WITHDRAWAL_RESOLVED_EVENT = WITHDRAWAL_RESOLVED_EVENT;
exports.WithdrawName = WithdrawName;
exports.WithdrawResolverEncoding = WithdrawResolverEncoding;
exports.WithdrawStateEncoding = WithdrawStateEncoding;
exports.enumify = enumify;
exports.tidy = tidy;
